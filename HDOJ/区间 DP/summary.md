### Dire Wolf 
状态设计：dp[i][j] 表示不猎取 i, j，但其他都被猎杀时，受到的最小攻击。

### You Are the One
改变顺序的方式相当于是一个栈，最先进去的会最后出来。
设 dp[i][j] 表示区间 (i,j) 的最小花费。转移时枚举第一个人放到哪里。注意这里每个区间都从 1 开始标号。

### Palindrome subsequence
设 dp[i][j] 表示 (i,j) 回文子序列数量。
```cpp
dp[i][j] = 0;
if (s[i] == s[j]) {
    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % mod;
} else {
    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + mod - dp[i + 1][j - 1]) % mod;
}
```

### A. Two Rabbits
可以发现两只兔子走过的路总长度不会大于 n。
只用求所有长度为 n 的区间的最长回文串长度就行。
另外还要考虑两只兔子从同一个起点出发。

### B. QSC and Master 
设 dp[i][j] 表示 (i,j) 的最大收益。
当计算 dp[i][j] 时：

1. 可以从 dp[i][k] + dp[k + 1][j] 转移而来，意思是 (k,k+1) 没有在一起被删除
2. 如果 (i + 1，j - 1) 可以被全部删除并且 i 和 j 可以作为一对删除，那么也可以从 dp[i + 1][j - 1] + a[i] + a[j] 转移

### C. String painter 
和上一题差不多的思路。
但是要考虑情况 2 时，会影响到中间的颜色。于是可以先预处理某个区间全是某个颜色时的最小步数。

### D. Jam's maze
想象有两个人，一个从(1,1)出发，另一个从(n,n)出发。每次走相同的字符的格子，最后在副对角线上回合，有多少种走法。
设 dp[step][x1][y1][x2][y2] 表示方案数。
这个状态可以精简，因为可以用横坐标计算出纵坐标。
并且第一维也可以用滚动数组优化。

### E. Expression
设 dp[i][j] 表示答案。
合并两个子区间时候，要考虑增加的操作方式。比如说两边都得到和之前相同的结果，但是有$\binom{j-i}{k-i}种新得操作方式，也就是左右自区间分别按原顺序可以交替操作。
1. 乘法：$(a_1+a_2+...+a_k)\times (b_1+b_2+...b_k)$
2. 加法： 加分和乘法不同，不能简单直接相加。考虑左边得到某个结果 x， 这个 x 实际上最后出现了 (右区间操作符号个数)！次

### F. Fragrant numbers 
如果能够表达出某个数，需要的区间长度不会很长。  
~~好吧我也不会证明。~~
于是暴力求出每个区间能够表达出哪些数字。